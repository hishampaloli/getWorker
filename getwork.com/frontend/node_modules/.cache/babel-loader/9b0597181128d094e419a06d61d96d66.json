{"ast":null,"code":"import { animateCSSModeScroll } from '../../shared/utils.js';\nexport default function slideTo() {\n  let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  let speed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.params.speed;\n  let runCallbacks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  let internal = arguments.length > 3 ? arguments[3] : undefined;\n  let initial = arguments.length > 4 ? arguments[4] : undefined;\n\n  if (typeof index !== 'number' && typeof index !== 'string') {\n    throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof index}] given.`);\n  }\n\n  if (typeof index === 'string') {\n    /**\n     * The `index` argument converted from `string` to `number`.\n     * @type {number}\n     */\n    const indexAsNumber = parseInt(index, 10);\n    /**\n     * Determines whether the `index` argument is a valid `number`\n     * after being converted from the `string` type.\n     * @type {boolean}\n     */\n\n    const isValidNumber = isFinite(indexAsNumber);\n\n    if (!isValidNumber) {\n      throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index}] given.`);\n    } // Knowing that the converted `index` is a valid number,\n    // we can update the original argument's value.\n\n\n    index = indexAsNumber;\n  }\n\n  const swiper = this;\n  let slideIndex = index;\n  if (slideIndex < 0) slideIndex = 0;\n  const {\n    params,\n    snapGrid,\n    slidesGrid,\n    previousIndex,\n    activeIndex,\n    rtlTranslate: rtl,\n    wrapperEl,\n    enabled\n  } = swiper;\n\n  if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {\n    return false;\n  }\n\n  const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\n  let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\n  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n  const translate = -snapGrid[snapIndex]; // Normalize slideIndex\n\n  if (params.normalizeSlideIndex) {\n    for (let i = 0; i < slidesGrid.length; i += 1) {\n      const normalizedTranslate = -Math.floor(translate * 100);\n      const normalizedGrid = Math.floor(slidesGrid[i] * 100);\n      const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);\n\n      if (typeof slidesGrid[i + 1] !== 'undefined') {\n        if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {\n          slideIndex = i;\n        } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {\n          slideIndex = i + 1;\n        }\n      } else if (normalizedTranslate >= normalizedGrid) {\n        slideIndex = i;\n      }\n    }\n  } // Directions locks\n\n\n  if (swiper.initialized && slideIndex !== activeIndex) {\n    if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {\n      return false;\n    }\n\n    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {\n      if ((activeIndex || 0) !== slideIndex) return false;\n    }\n  }\n\n  if (slideIndex !== (previousIndex || 0) && runCallbacks) {\n    swiper.emit('beforeSlideChangeStart');\n  } // Update progress\n\n\n  swiper.updateProgress(translate);\n  let direction;\n  if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset'; // Update Index\n\n  if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {\n    swiper.updateActiveIndex(slideIndex); // Update Height\n\n    if (params.autoHeight) {\n      swiper.updateAutoHeight();\n    }\n\n    swiper.updateSlidesClasses();\n\n    if (params.effect !== 'slide') {\n      swiper.setTranslate(translate);\n    }\n\n    if (direction !== 'reset') {\n      swiper.transitionStart(runCallbacks, direction);\n      swiper.transitionEnd(runCallbacks, direction);\n    }\n\n    return false;\n  }\n\n  if (params.cssMode) {\n    const isH = swiper.isHorizontal();\n    const t = rtl ? translate : -translate;\n\n    if (speed === 0) {\n      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n\n      if (isVirtual) {\n        swiper.wrapperEl.style.scrollSnapType = 'none';\n        swiper._immediateVirtual = true;\n      }\n\n      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n\n      if (isVirtual) {\n        requestAnimationFrame(() => {\n          swiper.wrapperEl.style.scrollSnapType = '';\n          swiper._swiperImmediateVirtual = false;\n        });\n      }\n    } else {\n      if (!swiper.support.smoothScroll) {\n        animateCSSModeScroll({\n          swiper,\n          targetPosition: t,\n          side: isH ? 'left' : 'top'\n        });\n        return true;\n      }\n\n      wrapperEl.scrollTo({\n        [isH ? 'left' : 'top']: t,\n        behavior: 'smooth'\n      });\n    }\n\n    return true;\n  }\n\n  swiper.setTransition(speed);\n  swiper.setTranslate(translate);\n  swiper.updateActiveIndex(slideIndex);\n  swiper.updateSlidesClasses();\n  swiper.emit('beforeTransitionStart', speed, internal);\n  swiper.transitionStart(runCallbacks, direction);\n\n  if (speed === 0) {\n    swiper.transitionEnd(runCallbacks, direction);\n  } else if (!swiper.animating) {\n    swiper.animating = true;\n\n    if (!swiper.onSlideToWrapperTransitionEnd) {\n      swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\n        if (!swiper || swiper.destroyed) return;\n        if (e.target !== this) return;\n        swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n        swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);\n        swiper.onSlideToWrapperTransitionEnd = null;\n        delete swiper.onSlideToWrapperTransitionEnd;\n        swiper.transitionEnd(runCallbacks, direction);\n      };\n    }\n\n    swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n    swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);\n  }\n\n  return true;\n}","map":{"version":3,"names":["animateCSSModeScroll","slideTo","index","speed","params","runCallbacks","internal","initial","Error","indexAsNumber","parseInt","isValidNumber","isFinite","swiper","slideIndex","snapGrid","slidesGrid","previousIndex","activeIndex","rtlTranslate","rtl","wrapperEl","enabled","animating","preventInteractionOnTransition","skip","Math","min","slidesPerGroupSkip","snapIndex","floor","slidesPerGroup","length","translate","normalizeSlideIndex","i","normalizedTranslate","normalizedGrid","normalizedGridNext","initialized","allowSlideNext","minTranslate","allowSlidePrev","maxTranslate","emit","updateProgress","direction","updateActiveIndex","autoHeight","updateAutoHeight","updateSlidesClasses","effect","setTranslate","transitionStart","transitionEnd","cssMode","isH","isHorizontal","t","isVirtual","virtual","style","scrollSnapType","_immediateVirtual","requestAnimationFrame","_swiperImmediateVirtual","support","smoothScroll","targetPosition","side","scrollTo","behavior","setTransition","onSlideToWrapperTransitionEnd","e","destroyed","target","$wrapperEl","removeEventListener","addEventListener"],"sources":["C:/webDevelepments/mernApp/MasterProject1/getwork.com/frontend/node_modules/swiper/core/slide/slideTo.js"],"sourcesContent":["import { animateCSSModeScroll } from '../../shared/utils.js';\nexport default function slideTo(index = 0, speed = this.params.speed, runCallbacks = true, internal, initial) {\n  if (typeof index !== 'number' && typeof index !== 'string') {\n    throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof index}] given.`);\n  }\n\n  if (typeof index === 'string') {\n    /**\n     * The `index` argument converted from `string` to `number`.\n     * @type {number}\n     */\n    const indexAsNumber = parseInt(index, 10);\n    /**\n     * Determines whether the `index` argument is a valid `number`\n     * after being converted from the `string` type.\n     * @type {boolean}\n     */\n\n    const isValidNumber = isFinite(indexAsNumber);\n\n    if (!isValidNumber) {\n      throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index}] given.`);\n    } // Knowing that the converted `index` is a valid number,\n    // we can update the original argument's value.\n\n\n    index = indexAsNumber;\n  }\n\n  const swiper = this;\n  let slideIndex = index;\n  if (slideIndex < 0) slideIndex = 0;\n  const {\n    params,\n    snapGrid,\n    slidesGrid,\n    previousIndex,\n    activeIndex,\n    rtlTranslate: rtl,\n    wrapperEl,\n    enabled\n  } = swiper;\n\n  if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {\n    return false;\n  }\n\n  const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\n  let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\n  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n  const translate = -snapGrid[snapIndex]; // Normalize slideIndex\n\n  if (params.normalizeSlideIndex) {\n    for (let i = 0; i < slidesGrid.length; i += 1) {\n      const normalizedTranslate = -Math.floor(translate * 100);\n      const normalizedGrid = Math.floor(slidesGrid[i] * 100);\n      const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);\n\n      if (typeof slidesGrid[i + 1] !== 'undefined') {\n        if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {\n          slideIndex = i;\n        } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {\n          slideIndex = i + 1;\n        }\n      } else if (normalizedTranslate >= normalizedGrid) {\n        slideIndex = i;\n      }\n    }\n  } // Directions locks\n\n\n  if (swiper.initialized && slideIndex !== activeIndex) {\n    if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {\n      return false;\n    }\n\n    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {\n      if ((activeIndex || 0) !== slideIndex) return false;\n    }\n  }\n\n  if (slideIndex !== (previousIndex || 0) && runCallbacks) {\n    swiper.emit('beforeSlideChangeStart');\n  } // Update progress\n\n\n  swiper.updateProgress(translate);\n  let direction;\n  if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset'; // Update Index\n\n  if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {\n    swiper.updateActiveIndex(slideIndex); // Update Height\n\n    if (params.autoHeight) {\n      swiper.updateAutoHeight();\n    }\n\n    swiper.updateSlidesClasses();\n\n    if (params.effect !== 'slide') {\n      swiper.setTranslate(translate);\n    }\n\n    if (direction !== 'reset') {\n      swiper.transitionStart(runCallbacks, direction);\n      swiper.transitionEnd(runCallbacks, direction);\n    }\n\n    return false;\n  }\n\n  if (params.cssMode) {\n    const isH = swiper.isHorizontal();\n    const t = rtl ? translate : -translate;\n\n    if (speed === 0) {\n      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n\n      if (isVirtual) {\n        swiper.wrapperEl.style.scrollSnapType = 'none';\n        swiper._immediateVirtual = true;\n      }\n\n      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n\n      if (isVirtual) {\n        requestAnimationFrame(() => {\n          swiper.wrapperEl.style.scrollSnapType = '';\n          swiper._swiperImmediateVirtual = false;\n        });\n      }\n    } else {\n      if (!swiper.support.smoothScroll) {\n        animateCSSModeScroll({\n          swiper,\n          targetPosition: t,\n          side: isH ? 'left' : 'top'\n        });\n        return true;\n      }\n\n      wrapperEl.scrollTo({\n        [isH ? 'left' : 'top']: t,\n        behavior: 'smooth'\n      });\n    }\n\n    return true;\n  }\n\n  swiper.setTransition(speed);\n  swiper.setTranslate(translate);\n  swiper.updateActiveIndex(slideIndex);\n  swiper.updateSlidesClasses();\n  swiper.emit('beforeTransitionStart', speed, internal);\n  swiper.transitionStart(runCallbacks, direction);\n\n  if (speed === 0) {\n    swiper.transitionEnd(runCallbacks, direction);\n  } else if (!swiper.animating) {\n    swiper.animating = true;\n\n    if (!swiper.onSlideToWrapperTransitionEnd) {\n      swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\n        if (!swiper || swiper.destroyed) return;\n        if (e.target !== this) return;\n        swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n        swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);\n        swiper.onSlideToWrapperTransitionEnd = null;\n        delete swiper.onSlideToWrapperTransitionEnd;\n        swiper.transitionEnd(runCallbacks, direction);\n      };\n    }\n\n    swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n    swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);\n  }\n\n  return true;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}